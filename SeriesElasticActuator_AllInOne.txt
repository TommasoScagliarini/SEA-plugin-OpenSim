#ifndef OPENSIM_SERIES_ELASTIC_ACTUATOR_H_
#define OPENSIM_SERIES_ELASTIC_ACTUATOR_H_

#include <OpenSim/OpenSim.h>
#include <OpenSim/Simulation/Model/Actuator.h>

namespace OpenSim {

class SeriesElasticActuator : public Actuator {
    OpenSim_DECLARE_CONCRETE_OBJECT(SeriesElasticActuator, Actuator);

public:
    //==============================================================================
    // PROPRIETÀ
    //==============================================================================
    OpenSim_DECLARE_PROPERTY(motor_inertia, double, "Inerzia del rotore (kg*m^2).");
    OpenSim_DECLARE_PROPERTY(motor_damping, double, "Smorzamento viscoso (N*m*s/rad).");
    OpenSim_DECLARE_PROPERTY(stiffness, double, "Rigidezza della molla (N*m/rad).");

    //==============================================================================
    // SOCKETS
    //==============================================================================
    OpenSim_DECLARE_SOCKET(coordinate, Coordinate, "La coordinata su cui agisce il SEA.");

    //==============================================================================
    // COSTRUTTORE
    //==============================================================================
    SeriesElasticActuator() {
        constructProperties();
    }

    SeriesElasticActuator(const std::string& name, double inertia, double damping, double k) {
        constructProperties();
        setName(name);
        set_motor_inertia(inertia);
        set_motor_damping(damping);
        set_stiffness(k);
    }

    // Specifica che l'attuatore accetta 1 controllo (Input al motore)
    int numControls() const override { return 1; }

protected:
    //==============================================================================
    // 1. DEFINIZIONE STATI
    //==============================================================================
    void extendAddToSystem(SimTK::MultibodySystem& system) const override {
        Super::extendAddToSystem(system);
        addStateVariable("motor_angle", SimTK::Stage::Dynamics);
        addStateVariable("motor_speed", SimTK::Stage::Dynamics);
    }

    //==============================================================================
    // 2. CALCOLO DERIVATE (Questa è la funzione che dava errore!)
    //==============================================================================
    void computeStateVariableDerivatives(const SimTK::State& s) const override {
        Super::computeStateVariableDerivatives(s);

        // Parametri
        double Jm = get_motor_inertia();
        double Bm = get_motor_damping();
        double K  = get_stiffness();
        if(Jm < 1e-9) Jm = 1e-9; // Protezione divisione per zero

        // Stati attuali
        double theta_m = getStateVariableValue(s, "motor_angle");
        double omega_m = getStateVariableValue(s, "motor_speed");

        // Stato della coordinata (Lato Arto)
        const Coordinate& coord = getConnectee<Coordinate>("coordinate");
        double theta_joint = coord.getValue(s); 

        // Input di controllo (Coppia Motore)
        double tau_input = 0.0;
        if(!isCacheVariableValid(s, "control")) {
         // Gestione di sicurezza se il controllo non è ancora stato calcolato
         tau_input = 0.0; 
    } else {
         tau_input = getControls(s)[0];
    }

        // --- DINAMICA SEA ---
        // Coppia elastica generata dalla molla
        double tau_spring = K * (theta_m - theta_joint);

        // Equazioni del moto del motore: 
        // 1. Derivata posizione = velocità
        double theta_m_dot = omega_m;
        // 2. Derivata velocità = (Coppia_motore - Coppia_molla - Attrito) / Inerzia
        double omega_m_dot = (tau_input - tau_spring - (Bm * omega_m)) / Jm;

        // SETTAGGIO DERIVATE
        setStateVariableDerivativeValue(s, "motor_angle", theta_m_dot);
        setStateVariableDerivativeValue(s, "motor_speed", omega_m_dot);
    }

    //==============================================================================
    // 3. APPLICAZIONE FORZA (Al corpo umano)
    //==============================================================================
    void computeForce(const SimTK::State& s, 
                      SimTK::Vector_<SimTK::SpatialVec>& bodyForces, 
                      SimTK::Vector& generalizedForces) const override {
        
        double K = get_stiffness();
        double theta_m = getStateVariableValue(s, "motor_angle");
        
        const Coordinate& coord = getConnectee<Coordinate>("coordinate");
        double theta_joint = coord.getValue(s);

        // La forza che la molla applica al giunto
        double tau_transmitted = K * (theta_m - theta_joint);

        applyGeneralizedForce(s, coord, tau_transmitted, generalizedForces);
    }

    //==============================================================================
    // 4. POTENZA
    //==============================================================================
    double getPower(const SimTK::State& s) const override {
        double omega_m = getStateVariableValue(s, "motor_speed");
        double input = 0.0;
        // if(!getControls(s).empty()) input = getControls(s)[0];
        return input * omega_m;
    }

private:
    void constructProperties() {
        constructProperty_motor_inertia(0.1);
        constructProperty_motor_damping(0.01);
        constructProperty_stiffness(1000.0);
    }
};

} // namespace OpenSim

#endif // OPENSIM_SERIES_ELASTIC_ACTUATOR_H_